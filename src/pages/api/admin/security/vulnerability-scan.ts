/**
 * 보안 취약점 스캔 API
 * 관리자만 접근 가능한 보안 스캔 엔드포인트
 */
import { NextApiRequest, NextApiResponse } from 'next'
import { vulnerabilityScanner } from '@/lib/security/vulnerabilityScanner'
import { createSecurityLog } from '@/lib/inviteCodeSecurity'
import { supabase } from '@/lib/supabase'

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  // CORS 헤더 설정
  res.setHeader('Access-Control-Allow-Origin', '*')
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization')

  if (req.method === 'OPTIONS') {
    return res.status(200).end()
  }

  try {
    // 관리자 권한 확인
    const authHeader = req.headers.authorization
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ error: '인증이 필요합니다' })
    }

    const token = authHeader.substring(7)
    const { data: { user }, error: authError } = await supabase.auth.getUser(token)

    if (authError || !user) {
      return res.status(401).json({ error: '유효하지 않은 토큰입니다' })
    }

    // 관리자 권한 확인
    const { data: admin, error: adminError } = await supabase
      .from('admins')
      .select('*')
      .eq('user_id', user.id)
      .eq('is_active', true)
      .single()

    if (adminError || !admin) {
      return res.status(403).json({ error: '관리자 권한이 필요합니다' })
    }

    // 요청 메서드별 처리
    switch (req.method) {
      case 'GET':
        return await handleGetScanResults(req, res, user.id)
      case 'POST':
        return await handleRunScan(req, res, user.id)
      default:
        return res.status(405).json({ error: '지원하지 않는 메서드입니다' })
    }
  } catch (error) {
    console.error('보안 스캔 API 오류:', error)
    return res.status(500).json({ 
      error: '서버 오류가 발생했습니다',
      details: error instanceof Error ? error.message : '알 수 없는 오류'
    })
  }
}

// 스캔 결과 조회
async function handleGetScanResults(req: NextApiRequest, res: NextApiResponse, adminId: string) {
  try {
    const { scanId, latest } = req.query

    if (scanId) {
      // 특정 스캔 결과 조회
      const { data: scanReport, error } = await supabase
        .from('security_scan_reports')
        .select('*')
        .eq('scan_id', scanId)
        .single()

      if (error || !scanReport) {
        return res.status(404).json({ error: '스캔 결과를 찾을 수 없습니다' })
      }

      return res.status(200).json({ scanReport })
    } else if (latest === 'true') {
      // 최신 스캔 결과 조회
      const { data: latestScan, error } = await supabase
        .from('security_scan_reports')
        .select('*')
        .order('timestamp', { ascending: false })
        .limit(1)
        .single()

      if (error || !latestScan) {
        return res.status(404).json({ error: '스캔 결과가 없습니다' })
      }

      return res.status(200).json({ scanReport: latestScan })
    } else {
      // 전체 스캔 기록 조회
      const { data: scanHistory, error } = await supabase
        .from('security_scan_reports')
        .select('scan_id, timestamp, overall_score, critical_issues, high_issues, medium_issues, low_issues')
        .order('timestamp', { ascending: false })
        .limit(50)

      if (error) {
        return res.status(500).json({ error: '스캔 기록 조회 실패' })
      }

      return res.status(200).json({ scanHistory: scanHistory || [] })
    }
  } catch (error) {
    console.error('스캔 결과 조회 오류:', error)
    return res.status(500).json({ error: '스캔 결과 조회 중 오류가 발생했습니다' })
  }
}

// 보안 스캔 실행
async function handleRunScan(req: NextApiRequest, res: NextApiResponse, adminId: string) {
  try {
    const { testId, fullScan = true } = req.body

    // 감사 로그 기록
    const log = createSecurityLog(
      'security_scan_initiated',
      adminId,
      req.headers['x-forwarded-for'] as string || req.connection.remoteAddress || 'unknown',
      req.headers['user-agent'] || 'unknown',
      {
        testId,
        fullScan,
        endpoint: req.url
      },
      true
    )

    await supabase.from('audit_logs').insert(log)

    if (fullScan) {
      // 전체 보안 스캔 실행
      const scanReport = await vulnerabilityScanner.runFullScan()
      
      return res.status(200).json({
        message: '보안 스캔이 완료되었습니다',
        scanReport
      })
    } else if (testId) {
      // 특정 테스트만 실행
      const result = await vulnerabilityScanner.runTest(testId)
      
      if (!result) {
        return res.status(404).json({ error: '존재하지 않는 테스트입니다' })
      }

      return res.status(200).json({
        message: '테스트가 완료되었습니다',
        result
      })
    } else {
      return res.status(400).json({ error: '테스트 ID 또는 전체 스캔 옵션이 필요합니다' })
    }
  } catch (error) {
    console.error('보안 스캔 실행 오류:', error)
    return res.status(500).json({ 
      error: '보안 스캔 실행 중 오류가 발생했습니다',
      details: error instanceof Error ? error.message : '알 수 없는 오류'
    })
  }
}